### `fs.readFile`将文件读到缓冲区 如果特别大 的文件就很占内存
### `webUpload`断点续传 百度出版 可以设置传的文件的大小

## 跨域相关
1.浏览器与服务端之间的跨域行为  端口 协议 域名 有一个不同就会产生跨域
2.`XMLHttpRequest`对象请求才有跨域行为<br>
3.`img.src` 也能发起get请求 多用于埋点<br>
4.`scripts src` 请求资源 不会有跨域行为<br>
5.服务端设置CORS允许跨域的域名<br>
6.`http-proxy-middleware`代理访问跨域的域名 （webpack的devServer实现原理就是express起的一个小服务器）

## 预检请求
一般限制请求有两种方式<br>
1.浏览器本身限制发起跨域请求<br>
2.跨域请求正常发起，但是返回的结果被浏览器拦截了<br>
3一般浏览器都是第二种方式发起的请求 虽然返回的结果被拦截了 但是 还是会操作服务端的数据 这样会有一定的风险为了规避这个风险
出现了预检请求 就是先发`options`通过之后 才会继续向下走<br>
4.但是并不是所有请求都会预检 产生预检请求是有一定规则的 比如<br>
5.使用`ge`t和`post`常见的两种传输方式的时候会因为`Content-Type`传的参数决定是否要预检请求post的 `Content-Type`是以下值的时候不会预检请求其他值都会<br>
* `text/plain`
* `multipart/form-data`
* `application/x-www-form-urlencoded`

6.使用 `put delete`的时候都会发起预检请求<br>
7.还有人为的设置`cors`首部安全字段的时候会发起预检请求

## Http强缓存策略

Http 1.0<br>
1.使用强缓存需要在服务端设置的expires 时间和本地的时间进行 比较如果本地时间大于expires设置的时间说明过期了去请求新的资源否则就是没过期直接走缓存不需要请求新资源这样的缺点是本地的时间是可以随意更改的所以导致比较时间不准确

```javascript
{res.setHeader('Expires', new Date(Date.now() + 10 * 1000).toUTCString())}
```

Http1.1<br>
1.使用cache-control当catche-control和expires都存在的时候cache-control优先级更高 可以设置max-age过期时间比如设置10分钟那么在这10分钟之内都是有效的会走缓存的资源不需要依赖本地浏览器判断还可以设置以下表格展示的值
```javascript
res.setHeader('Cache-Control', 'max-age=20')
```

Http1.1<br>
1.协商缓存策略`etag`优先级高于`last-modified`<br>
2.使用`last-modified`和`if-modified-since`两个属性第一次请求的时候服务端会响应一个`last-modified`到客户端之后在请求的时候客户端会将这个时间用`if-modified-since`带到服务端做判断，服务端判断如果不需要更新资源直接返回304状态码，反之需要更新资源返回200状态码并且返回新的资源<br>
3.通过etag和if-none-match来判断是否过期原理上和上面说的last-modified相似只是他们比较的是关键内容hash

### java相比node的优势在于 分布式技术 微服务架构

### Sequelize好处是可以使用对象的方式操作数据库而非sql语句操作成本大大降低

### 什么是连接池有什么优点

1.数据库连接池是负责分配、管理和释放数据库连接、它允许应用程序重复使用一个现有的数据库连接、而不是在建立一个<br>
2.减少网络开销<br>
3.系统的性能会有一个实质的提升<br>
4.没了麻烦的TIME_WAIT状态

## 一次数据库完整连接的步骤
1.tcp三次握手<br>
2.mysql认证的三次握手<br>
3.真正mysql执行<br>
4.mysql关闭<br>
5.tcp的四次握手关闭

## Cookie
缺点：
    1.明文传输不安全可能被篡改<br>
    2.容量有限制<br>
    3.无法存储对象实例

## Cookie和sessionCookie的区别
1.`session`将数据存储到服务器的每次传输`cookie`值都是`sessionid`<br>
2.`cookie`是将数据存储到浏览器的每次传输的都是值

### node js 单线程的存在问题

1.无法利用多核`cpu`<br>
2.错误会引起整个应用的退出，健壮性值的考虑<br>
3.大量计算占用`CPU`导致无法继续调用异步IO

### `node`通过`child_process`将计算任务分发到各个子进程然后在通过进程之间的事件消息来传递结果

### `Io`密集型的优势主要利用了`node`事件循环的处理能力，而不是启动每一个线程为每一个请求服务，资源占用极少

### `v8`引擎库是`node`自身动力的来源之一。由c++编写，可以实现node与c++之间的调用
### `libuv`库是node自身动力来源之二，Node能够实现跨平台的一个诀窍就是他的`libuv`库，这个库是跨平台的一层封装，通过他去调用一些底层操作，比自己在各个平台下编写实现要高效的多，`libuv`封装的功能包括事件循环和文件操作等

### `AMD`规范是`cjs`的一个延伸，实际就是异步模块定义，使用`define`声明目的就是作用域隔离仅在需要的时候进行引入

### `AMD`与`CMD`的规范主要区别与定义模块和依赖引入的部分，`AMD`需要在声明模块的时候指定所有的依赖，通过形参传递依赖到模块中，与`AMD`模块规范相比，`CMD`更接近用Node对`cjs`规范的定义在依赖部分`CMD`支持动态引入

### Node高性能的原因
1.`node`采用事件驱动的方式。处理请求无须为每一个请求创建额外的对应线程，可以省掉创建线程和销毁线程的开销，同时操作系统在调度任务时因为线程较少，上下文切换的代价很低，这使得服务器能够有条不紊的处理请求，即使在大量连接的情况下，也不受线程上下文切换开销的影响，这是`Node`高性能的原因之一
